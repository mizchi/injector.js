// Generated by CoffeeScript 1.6.2
(function() {
  var root, _ref,
    __slice = [].slice;

  root = (_ref = typeof window !== "undefined" && window !== null ? window : exports) != null ? _ref : this;

  root.Injector = (function() {
    var rootInjector;

    rootInjector = new Injector;

    Injector.register = function() {
      return rootInjector.register.apply(rootInjector, arguments);
    };

    Injector.unregister = function() {
      return rootInjector.unregister.apply(rootInjector, arguments);
    };

    Injector.mapSingleton = function() {
      return rootInjector.mapSingleton.apply(rootInjector, arguments);
    };

    Injector.mapValue = function() {
      return rootInjector.mapValue.apply(rootInjector, arguments);
    };

    Injector.unmap = function() {
      return rootInjector.unmap.apply(rootInjector, arguments);
    };

    Injector.ensureProperties = function(instance) {
      var k, v, _ref1;

      _ref1 = instance.constructor.inject;
      for (k in _ref1) {
        v = _ref1[k];
        if (instance.hasOwnProperty(k)) {
          throw new Error("Injected property must not be object own property");
        }
        if (!instance[k]) {
          throw new Error("lack of [" + k + "] on initialize");
        }
      }
      return true;
    };

    function Injector() {
      this.known_list = [];
    }

    Injector.prototype.register = function(Listener) {
      var key, _results;

      this.known_list.push(Listener);
      _results = [];
      for (key in Listener.inject) {
        _results.push(Object.defineProperty(Listener.prototype, key, {
          value: null,
          writable: false,
          configurable: true
        }));
      }
      return _results;
    };

    Injector.prototype.unregister = function(Listener) {
      var Class, n, prop, _ref1;

      n = this.known_list.indexOf(Listener);
      _ref1 = Listener.inject;
      for (prop in _ref1) {
        Class = _ref1[prop];
        Object.defineProperty(Listener.prototype, prop, {
          get: function() {
            this['_' + prop] = null;
            return null;
          },
          configurable: true
        });
      }
      return this.known_list.splice(n, 1);
    };

    Injector.prototype.mapValue = function() {
      var Class, args;

      Class = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      return this.known_list.forEach(function(Listener) {
        var cnt_key, instance_key, key, val, _ref1, _results;

        _ref1 = Listener.inject;
        _results = [];
        for (key in _ref1) {
          val = _ref1[key];
          if (!(val === Class)) {
            continue;
          }
          cnt_key = "update#" + key;
          if (Listener[cnt_key] != null) {
            Listener[cnt_key]++;
          } else {
            Object.defineProperty(Listener, cnt_key, {
              value: 0,
              enumerable: false,
              writable: true
            });
          }
          instance_key = "_" + key;
          _results.push(Object.defineProperty(Listener.prototype, key, {
            enumerable: false,
            configurable: true,
            get: function() {
              if (Listener[cnt_key] > this[cnt_key]) {
                delete this[instance_key];
              }
              if (!this[instance_key]) {
                this[instance_key] = (function(func, args, ctor) {
                  ctor.prototype = func.prototype;
                  var child = new ctor, result = func.apply(child, args);
                  return Object(result) === result ? result : child;
                })(Class, args, function(){});
                Object.defineProperty(this, cnt_key, {
                  value: Listener[cnt_key],
                  enumerable: false,
                  configurable: true
                });
              }
              return this[instance_key];
            }
          }));
        }
        return _results;
      });
    };

    Injector.prototype.mapSingleton = function(Class, instance) {
      if (!(instance instanceof Class)) {
        throw "" + instance + " is not " + Class + " instance";
      }
      return this.known_list.forEach(function(Listener) {
        var key, val, _ref1, _results;

        _ref1 = Listener.inject;
        _results = [];
        for (key in _ref1) {
          val = _ref1[key];
          if (!(val === Class)) {
            continue;
          }
          if (Listener.prototype[key]) {
            throw "" + key + " already exists";
          }
          _results.push(Listener.prototype[key] = instance);
        }
        return _results;
      });
    };

    Injector.prototype.unmap = function(Class) {
      if (Class == null) {
        Class = null;
      }
      return this.known_list.forEach(function(Listener) {
        var key, val, _ref1, _results;

        _ref1 = Listener.inject;
        _results = [];
        for (key in _ref1) {
          val = _ref1[key];
          if (!(Class != null) || val === Class) {
            _results.push(Object.defineProperty(Listener.prototype, key, {
              value: null,
              writable: false,
              configurable: true
            }));
          }
        }
        return _results;
      });
    };

    return Injector;

  })();

  if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {
    define(function() {
      return Injector;
    });
  }

}).call(this);
